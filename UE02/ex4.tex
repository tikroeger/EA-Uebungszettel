\documentclass[a4paper,10pt]{scrartcl}
\usepackage[utf8x]{inputenc}

\begin{document}

\section*{Aufgabe 4}

\paragraph{a)}

\begin{verbatim}
    def adjc(u, G):
        # Returns a list of adjecent nodes to node u in graph G.

    def dist(u, v, G):
        if u == v:
            return 1
        else:
            return min([dist(u_1, v, G) for u_1 in adjc(u, G)])+1

    def diameter(G):
        return max([dist(u, v) for u, v in G])
\end{verbatim}

\paragraph{b)}

\begin{verbatim}
def tree_diameter(root, height=1):
    d_1, lh = tree_diameter(left(root), height+1)
    d_2, rh = tree_diameter(right(root), height+1)

    return max([d_1, d_2, (lh + rh + 1)]), max([lh, rh])
\end{verbatim}

Die Suche nach dem längsten Pfad fängt mit der Wurzel des Baumes an.
Dabei gibt es drei Fälle zu beachten.

\subparagraph{Fall 1 -- Der längste Pfad ist vollständig im linken Teilbaum}

In diesem Fall liefert \emph{tree\_diameter(left)} den längsten Pfad.

\subparagraph{Fall 2 -- Der längste Pfad ist vollständig im rechten Teilbaum}

In diesem Fall liefert \emph{tree\_diameter(right)} den längsten Pfad.

\subparagraph{Fall 3 -- Der längste Pfad geht durch den Knoten}

In diesem Fall muss der längste Pfad gleich $l_h + r_h + 1$ sein, wobei $l_h$ die Höhe des linken
Teilbaumes ist und $r_h$ die Höhe des rechten Teilbaumes ist, zusätzlich wird noch der gegenwärtige
Knoten gerechnet.

Die Höhe eines Teilbaumes ist nämlich der längste Pfad bis zur Wurzel.
Wenn die Wurzel Teil des längsten Pfades ist, muss der Pfad vom höchsten Knoten eines Teilbaumes über die Wurzel
zum höchsten Knoten des anderen Teilbaumes verlaufen.

\subparagraph{Komplexität}

Der Algorithmus besucht jeden Knoten einmal, also hat er eine Komplexität von $O(n)$.

\section*{Aufgabe 5}

\# TODO

\section*{Aufgabe 6}

\begin{verbatim}
    def init(G):
        for v in G:
            if in_deg(v) == 0:
                follow(v)

    def follow(v):
        print(v)
        remove(v)
        for u in adjc(v):
            if in_deg(u) == 0:
                follow(v)

    def top_sort(G): init(G)
\end{verbatim}

Wenn es einen Kreis gibt ($u \rightarrow v \rightarrow w \rightarrow u$), so hat keiner der Knoten den Eingangsgrad 0.
Der Algorithmus kann diesen Kreis nicht auflösen und er bleibt bestehen.

Hat der Graph mehrere Kreise so bleiben alle bestehen,
der Graph ist dann aber nicht mehr notwendigerweise zusammenhängend.

\end{document}
