\documentclass[a4paper,10pt]{scrartcl}
\usepackage[utf8x]{inputenc}

\begin{document}

\section*{Aufgabe 4}

\paragraph{a)}

\begin{verbatim}
    def mark(u):
        # Markiere Knoten u in Graph G. Die Markierung gilt nur für
        # alle nachfolgenden Operationen. Wird die Funktion verlassen
        # so erlischt die Markierung.

    def marked(u):
        # Ist Knoten u in Graph G markiert?

    def adjc(u):
        # Gibt die Liste der adjezenten Knoten zurück.

    def dist(u, v):
        if not marked(u):
            mark(u)
            if u == v:
                return 0
            else:
                return min([dist(u_1, v) for u_1 in adjc(u)])+1
        else:
            return infinity

    def diameter(G):
        return max([dist(u, v, G) for u, v in G])
\end{verbatim}

\subparagraph{Korrektheit}

\emph{dist(u, v, G)} berechnet den kleinsten Abstand zwischen zwei Knoten u und v.


Ist der Knoten u markiert so ist er bereits Teil des Weges. Die Funktion is im Kreis gelaufen.
Die Länge unendlich wird zurückgegeben, sodass dieser Weg in der Wahl der Wege nicht berücksichtigt wird.

Ist der Knoten u nicht markiert kann man zwei Fälle unterscheiden:


Falls $u \neq v$ dann folgt \emph{dist} allen Kanten von u.


Falls $u = v$ dann gibt \emph{dist} 0 zurück.


Es wird also ein Weg (falls es einen gibt) von u nach v gefunden.
Da \emph{dist} alle Alternativen überprüft werden alle Wege von u nach v gefunden.
Die Funktion \emph{min} wählt den kürzesten, und gibt die Länge zurück.

Es wird rekursiv immer der kürzeste Weg zurückgegeben, bis die Länge des kürzesten Weges von u nach v bekannt ist.

\emph{diameter(G)} wählt den längsten kürzesten Pfad zwischen allen Paaren von u, v im Graphen G.
Somit wird der Durchmesser des Graphen berechnet.

\subparagraph{Komplexität}

Alle Paare aller Kanten in G, die die Funktion \emph{diameter} enumeriert: $O(E^2)$.

Alle Wege in einem Graphen G, die die Funktioen \emph{dist} enumeriert: $O(V+E)$

Gesamtkomplexität: $O((V+E)*E^2)$

\paragraph{b)}

\begin{verbatim}
def tree_diameter(root, height=1):
    for n in adjc(root):
        d, h = tree_diameter(n, height+1)
        ds.append(d)
        hs.append(h)

    hs_1 = sort(hs, reversed=True) # Absteigend

    return max(max(ds), hs_1[0] + hs_1[1] + 1)
\end{verbatim}

Die Suche nach dem längsten Pfad fängt mit der Wurzel des Baumes an.
Dabei gibt es zwei Fälle zu beachten.

\subparagraph{Fall 1 -- Der längste Pfad ist vollständig in einem Teilbaum}

In diesem Fall liefert \emph{tree\_diameter(n)} (der Durchmesser eben dieses Teilbaumes) den längsten Pfad.

\subparagraph{Fall 2 -- Der längste Pfad geht durch den Wurzelknoten}

In diesem Fall geht der längste Pfad von dem höchsten Teilbaum über den Wurzelknoten zum zweithöchsten Teilbaum.

Die Höhe eines Teilbaumes ist nämlich der längste Pfad bis zur Wurzel.
Wenn die Wurzel Teil des längsten Pfades ist, muss der Pfad vom höchsten Knoten eines Teilbaumes über die Wurzel
zum höchsten Knoten des anderen Teilbaumes verlaufen.

Dabei ist die Länge die Höhe der beiden höchsten Teilbäume plus eins für den Wurzelknoten.

\subparagraph{Komplexität}

Der Algorithmus besucht jeden Knoten einmal, also hat er eine Komplexität von $O(n)$.

\section*{Aufgabe 5}

\# TODO

\pagebreak % Quelltext nicht über zwei Seiten.

\section*{Aufgabe 6}

\begin{verbatim}
    def init(G):
        for v in G:
            if in_deg(v) == 0:
                follow(v)

    def follow(v):
        print(v)
        remove(v)
        for u in adjc(v):
            if in_deg(u) == 0:
                follow(v)

    def top_sort(G): init(G)
\end{verbatim}

Wenn es einen Kreis gibt ($u \rightarrow v \rightarrow w \rightarrow u$), so hat keiner der Knoten den Eingangsgrad 0.
Der Algorithmus kann diesen Kreis nicht auflösen und er bleibt bestehen.

Hat der Graph mehrere Kreise so bleiben alle bestehen,
der Graph ist dann aber nicht mehr notwendigerweise zusammenhängend.  

\end{document}
